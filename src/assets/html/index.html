<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Random VRM Model & Animation Viewer</title>
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        html,
        body {
            height: 100%;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background-image: url('https://d1j8r0kxyu9tj8.cloudfront.net/files/NAKcx4iwrXL2mvZGRf67zkUzlGFIVMocgUbX4DdJ.png');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
        }

        /* Smooth background crossfade overlay */
        #bgFadeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 400ms ease;
            z-index: 0;
            /* below canvas (z-index:1), above body background */
            pointer-events: none;
        }

        /* Call mode background blur layer. We re-use #bgFadeOverlay with this class. */
        #bgFadeOverlay.call-blur {
            opacity: 1 !important;
            /* ensure visible during call mode */
            filter: blur(10px) saturate(1.05);
            /* soft blur with slight pop */
            transform: scale(1.03);
            /* hide blur edges */
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* Lift the rendered scene visually without changing model/camera coordinates */
            margin-top: -40px;
            /* adjust as desired */
            z-index: 1;
        }


        #divInfo {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-family: Arial, sans-serif;
            z-index: 1000;
            display: none;
        }

        #currentFiles {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ccc;
            font-size: 14px;
        }

        .file-info {
            margin: 5px 0;
            color: #555;
        }

        .file-name {
            font-weight: bold;
            color: #333;
        }

        #reloadBtn,
        #nextAnimBtn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }

        #reloadBtn:hover,
        #nextAnimBtn:hover {
            background: #5a67d8;
        }

        #nextAnimBtn {
            background: #48bb78;
        }

        #nextAnimBtn:hover {
            background: #38a169;
        }

        #reloadBtn:disabled,
        #nextAnimBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #nextAnimBtn:disabled:hover {
            background: #48bb78;
        }

        .lil-gui {
            display: none !important;
        }

        /* Floating action buttons (right side) */
        /* swift overlay buttons will replace web buttons */


        /* Loading overlay and blur */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.25);
            z-index: 1001;
            font-family: Arial, sans-serif;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
        }

        #loadingText {
            margin-top: 12px;
            font-size: 16px;
        }

        .loading-blur {
            filter: blur(6px) saturate(0.9) brightness(0.95);
            transition: filter 0.2s ease;
        }
    </style>
</head>

<body>
    <div id="bgFadeOverlay"></div>
    <div id="loadingOverlay">
        <svg width="44" height="44" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg" stroke="#fff">
            <g fill="none" fill-rule="evenodd" stroke-width="4">
                <circle cx="22" cy="22" r="18" stroke-opacity="0.3" />
                <path d="M40 22c0-9.94-8.06-18-18-18" stroke="#fff">
                    <animateTransform attributeName="transform" type="rotate" from="0 22 22" to="360 22 22" dur="1s"
                        repeatCount="indefinite" />
                </path>
            </g>
        </svg>
        <div id="loadingText">Loading... 0%</div>
    </div>
    <div id="divInfo">
        <strong>Random VRM & Animation Loader</strong><br>
        <span style="font-size: 12px; color: #666;">Drag and drop to override</span>
        <div id="currentFiles">
            <div class="file-info">Model: <span id="currentModel" class="file-name">Loading...</span></div>
            <div class="file-info">Animation: <span id="currentAnimation" class="file-name">Loading...</span></div>
        </div>
        <div style="display: flex; gap: 8px; margin-top: 10px;">
            <button id="reloadBtn" onclick="loadRandomFiles()">Load New Random</button>
            <button id="nextAnimBtn" onclick="loadNextAnimation()">Next Animation</button>
        </div>
    </div>

    <!-- Swift overlay buttons will be added in native UI -->

    <script type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/",
                    "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
                }
            }
        </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import GUI from 'three/addons/libs/lil-gui.module.min.js';

        // === Inlined from config.js ===
        const mixamoVRMRigMap = { "mixamorigHips": "hips", "mixamorigSpine": "spine", "mixamorigSpine1": "chest", "mixamorigSpine2": "upperChest", "mixamorigNeck": "neck", "mixamorigHead": "head", "mixamorigLeftShoulder": "leftShoulder", "mixamorigLeftArm": "leftUpperArm", "mixamorigLeftForeArm": "leftLowerArm", "mixamorigLeftHand": "leftHand", "mixamorigLeftHandThumb1": "leftThumbMetacarpal", "mixamorigLeftHandThumb2": "leftThumbProximal", "mixamorigLeftHandThumb3": "leftThumbDistal", "mixamorigLeftHandIndex1": "leftIndexProximal", "mixamorigLeftHandIndex2": "leftIndexIntermediate", "mixamorigLeftHandIndex3": "leftIndexDistal", "mixamorigLeftHandMiddle1": "leftMiddleProximal", "mixamorigLeftHandMiddle2": "leftMiddleIntermediate", "mixamorigLeftHandMiddle3": "leftMiddleDistal", "mixamorigLeftHandRing1": "leftRingProximal", "mixamorigLeftHandRing2": "leftRingIntermediate", "mixamorigLeftHandRing3": "leftRingDistal", "mixamorigLeftHandPinky1": "leftLittleProximal", "mixamorigLeftHandPinky2": "leftLittleIntermediate", "mixamorigLeftHandPinky3": "leftLittleDistal", "mixamorigRightShoulder": "rightShoulder", "mixamorigRightArm": "rightUpperArm", "mixamorigRightForeArm": "rightLowerArm", "mixamorigRightHand": "rightHand", "mixamorigRightHandThumb1": "rightThumbMetacarpal", "mixamorigRightHandThumb2": "rightThumbProximal", "mixamorigRightHandThumb3": "rightThumbDistal", "mixamorigRightHandIndex1": "rightIndexProximal", "mixamorigRightHandIndex2": "rightIndexIntermediate", "mixamorigRightHandIndex3": "rightIndexDistal", "mixamorigRightHandMiddle1": "rightMiddleProximal", "mixamorigRightHandMiddle2": "rightMiddleIntermediate", "mixamorigRightHandMiddle3": "rightMiddleDistal", "mixamorigRightHandRing1": "rightRingProximal", "mixamorigRightHandRing2": "rightRingIntermediate", "mixamorigRightHandRing3": "rightRingDistal", "mixamorigRightHandPinky1": "rightLittleProximal", "mixamorigRightHandPinky2": "rightLittleIntermediate", "mixamorigRightHandPinky3": "rightLittleDistal", "mixamorigLeftUpLeg": "leftUpperLeg", "mixamorigLeftLeg": "leftLowerLeg", "mixamorigLeftFoot": "leftFoot", "mixamorigLeftToeBase": "leftToes", "mixamorigRightUpLeg": "rightUpperLeg", "mixamorigRightLeg": "rightLowerLeg", "mixamorigRightFoot": "rightFoot", "mixamorigRightToeBase": "rightToes" };
        const genericVRMRigMap = { "Hips": "hips", "Spine": "spine", "Chest": "chest", "UpperChest": "upperChest", "Neck": "neck", "Head": "head", "LeftShoulder": "leftShoulder", "LeftUpperArm": "leftUpperArm", "LeftLowerArm": "leftLowerArm", "LeftHand": "leftHand", "RightShoulder": "rightShoulder", "RightUpperArm": "rightUpperArm", "RightLowerArm": "rightLowerArm", "RightHand": "rightHand", "LeftUpperLeg": "leftUpperLeg", "LeftLowerLeg": "leftLowerLeg", "LeftFoot": "leftFoot", "LeftToes": "leftToes", "RightUpperLeg": "rightUpperLeg", "RightLowerLeg": "rightLowerLeg", "RightFoot": "rightFoot", "RightToes": "rightToes", "hips": "hips", "spine": "spine", "chest": "chest", "upper_chest": "upperChest", "neck": "neck", "head": "head", "shoulder.L": "leftShoulder", "upper_arm.L": "leftUpperArm", "forearm.L": "leftLowerArm", "hand.L": "leftHand", "shoulder.R": "rightShoulder", "upper_arm.R": "rightUpperArm", "forearm.R": "rightLowerArm", "hand.R": "rightHand", "thigh.L": "leftUpperLeg", "shin.L": "leftLowerLeg", "foot.L": "leftFoot", "toe.L": "leftToes", "thigh.R": "rightUpperLeg", "shin.R": "rightLowerLeg", "foot.R": "rightFoot", "toe.R": "rightToes" };
        const combinedRigMap = { ...genericVRMRigMap, ...mixamoVRMRigMap };
        const vrmFiles = ["0001_01 2.vrm", "0001_01 3.vrm", "0001_02 2.vrm", "0001_02 3.vrm", "0001_02.vrm", "0001_03 2.vrm", "0001_03.vrm", "0001_04 2.vrm", "0001_04.vrm", "0001_05 2.vrm", "0001_05.vrm", "0001_06 2.vrm", "0001_06.vrm", "0001_07 2.vrm", "0001_07 3.vrm", "0001_07.vrm 2", "0001_07.vrm", "0001_08 2.vrm", "0001_08 3.vrm", "0001_08.vrm 2", "0001_08.vrm", "0001_09 2.vrm", "0001_09.vrm", "0001_10.vrm"];
        const fbxFiles = ["Angry.fbx", "Bashful.fbx", "Blow A Kiss.fbx", "Booty Hip Hop Dance.fbx", "Cross Jumps.fbx", "Hand Raising.fbx", "Happy.fbx", "Hip Hop Dancing.fbx", "Idle Stand.fbx", "Jumping Jacks.fbx", "Quick Steps.fbx", "Rumba Dancing.fbx", "Snake Hip Hop Dance.fbx", "Standing Arguing.fbx", "Standing Greeting.fbx", "Step Hip Hop Dance.fbx", "Talking.fbx", "Taunt.fbx", "Thinking.fbx", "Threatening.fbx"];
        const VRM_BASE_URL = 'https://n6n.top/Model/';
        const FBX_BASE_URL = 'https://n6n.top/Anim/';
        // Background music is controlled exclusively by Swift; no HTML-side audio.
        const namePatterns = { hips: /hip/i, spine: /spine/i, chest: /chest|spine1/i, upperChest: /upperchest|spine2/i, neck: /neck/i, head: /head/i, leftShoulder: /l(eft)?[-_\s]?shoulder/i, leftUpperArm: /l(eft)?[-_\s]?(upper)?[-_\s]?arm/i, leftLowerArm: /l(eft)?[-_\s]?(lower|fore)[-_\s]?arm/i, leftHand: /l(eft)?[-_\s]?hand/i, rightShoulder: /r(ight)?[-_\s]?shoulder/i, rightUpperArm: /r(ight)?[-_\s]?(upper)?[-_\s]?arm/i, rightLowerArm: /r(ight)?[-_\s]?(lower|fore)[-_\s]?arm/i, rightHand: /r(ight)?[-_\s]?hand/i, leftUpperLeg: /l(eft)?[-_\s]?(upper|up)[-_\s]?leg|l(eft)?[-_\s]?thigh/i, leftLowerLeg: /l(eft)?[-_\s]?(lower)?[-_\s]?leg|l(eft)?[-_\s]?(shin|calf)/i, leftFoot: /l(eft)?[-_\s]?foot/i, leftToes: /l(eft)?[-_\s]?(toe|toebase)/i, rightUpperLeg: /r(ight)?[-_\s]?(upper|up)[-_\s]?leg|r(ight)?[-_\s]?thigh/i, rightLowerLeg: /r(ight)?[-_\s]?(lower)?[-_\s]?leg|r(ight)?[-_\s]?(shin|calf)/i, rightFoot: /r(ight)?[-_\s]?foot/i, rightToes: /r(ight)?[-_\s]?(toe|toebase)/i };
        // === End inlined config ===

        // === Background preloading and cache ===
        const modelObjectURLCache = new Map(); // name -> Promise<objectURL>
        const animObjectURLCache = new Map();  // name -> Promise<objectURL>
        let preloadingStarted = false;

        // Splash gating: wait for first animation and background to be applied
        let initialAnimationApplied = false;
        let initialBackgroundReady = false;
        let progress100At = null; // timestamp when progress reached 100%
        let overlayHiddenAt = null; // timestamp when loading overlay was hidden
        let notifyTimer = null;
        function notifyInitialReadyIfDone() {
            try {
                console.log('üîç Checking initial ready:', {
                    animationApplied: initialAnimationApplied,
                    backgroundReady: initialBackgroundReady,
                    progress100: progress100At,
                    overlayHidden: overlayHiddenAt
                });

                if (!(initialAnimationApplied && initialBackgroundReady)) {
                    console.log('‚è≥ Waiting for:', {
                        needAnimation: !initialAnimationApplied,
                        needBackground: !initialBackgroundReady
                    });
                    return;
                }

                const now = performance.now();
                const t100 = progress100At ?? now;
                const thide = overlayHiddenAt ?? now;
                const target = Math.max(t100, thide) + 1000; // 1s after 100% + overlay hidden
                const waitMs = target - now;

                const sendReady = () => {
                    try {
                        console.log('‚úÖ Sending initialReady message...');
                        // iOS native WebKit message handler
                        window.webkit?.messageHandlers?.loading?.postMessage('initialReady');
                    } catch (e) {
                        console.error('Error sending to webkit:', e);
                    }
                    try {
                        // React Native WebView message handler
                        if (window.ReactNativeWebView) {
                            window.ReactNativeWebView.postMessage('initialReady');
                            console.log('‚úÖ Sent initialReady to ReactNativeWebView');
                        } else {
                            console.warn('‚ö†Ô∏è window.ReactNativeWebView not available');
                        }
                    } catch (e) {
                        console.error('Error sending to ReactNativeWebView:', e);
                    }
                };

                if (waitMs <= 0) {
                    sendReady();
                } else {
                    console.log(`‚è≥ Waiting ${waitMs}ms before sending initialReady...`);
                    if (notifyTimer) { clearTimeout(notifyTimer); }
                    notifyTimer = setTimeout(() => {
                        console.log('‚è∞ Timer fired, sending initialReady');
                        sendReady();
                    }, waitMs);
                }
            } catch (e) {
                console.error('Error in notifyInitialReadyIfDone:', e);
            }
        }

        function fetchAndCacheObjectURL(name, baseUrl, cacheMap) {
            if (cacheMap.has(name)) return cacheMap.get(name);
            const url = baseUrl + encodeURIComponent(name);
            const promise = fetch(url, { mode: 'cors' })
                .then(r => {
                    if (!r.ok) throw new Error('HTTP ' + r.status + ' for ' + name);
                    return r.blob();
                })
                .then(blob => URL.createObjectURL(blob))
                .catch(err => {
                    cacheMap.delete(name);
                    throw err;
                });
            cacheMap.set(name, promise);
            return promise;
        }

        async function withConcurrency(names, worker, concurrency = 3) {
            const queue = names.slice();
            const running = [];
            const results = [];
            while (queue.length > 0 || running.length > 0) {
                while (running.length < concurrency && queue.length > 0) {
                    const name = queue.shift();
                    const p = Promise.resolve().then(() => worker(name))
                        .then(res => ({ status: 'fulfilled', value: res, name }))
                        .catch(err => ({ status: 'rejected', reason: err, name }));
                    running.push(p);
                }
                const settled = await Promise.race(running.map((p, i) => p.then(v => ({ v, i }))));
                running.splice(settled.i, 1);
                results.push(settled.v);
            }
            return results;
        }

        async function startBackgroundPreloading(excludeModelName = null, excludeAnimationName = null) {
            if (preloadingStarted) return;
            preloadingStarted = true;
            try {
                const modelNames = vrmFiles.filter(n => n !== excludeModelName);
                const animNames = fbxFiles.filter(n => n !== excludeAnimationName);
                // Kick off both in parallel
                await Promise.all([
                    withConcurrency(modelNames, (name) => fetchAndCacheObjectURL(name, VRM_BASE_URL, modelObjectURLCache), 2),
                    withConcurrency(animNames, (name) => fetchAndCacheObjectURL(name, FBX_BASE_URL, animObjectURLCache), 3)
                ]);
                /* preloading completed */
            } catch (e) {
                /* background preloading finished with some errors */
            }
        }

        async function getModelURL(name) {
            if (!name) return null;
            if (modelObjectURLCache.has(name)) {
                try { return await modelObjectURLCache.get(name); } catch { /* fallthrough */ }
            }
            // If not cached, return remote URL and also start caching in background
            const remote = VRM_BASE_URL + encodeURIComponent(name);
            fetchAndCacheObjectURL(name, VRM_BASE_URL, modelObjectURLCache);
            return remote;
        }

        async function getAnimationURL(name) {
            if (!name) return null;
            if (animObjectURLCache.has(name)) {
                try { return await animObjectURLCache.get(name); } catch { /* fallthrough */ }
            }
            const remote = FBX_BASE_URL + encodeURIComponent(name);
            fetchAndCacheObjectURL(name, FBX_BASE_URL, animObjectURLCache);
            return remote;
        }

        function safeFileNameFromUrl(url) {
            try {
                // Handle blob: URLs and http(s): URLs
                if (!url) return null;
                const last = url.split('/').pop() || '';
                try { return decodeURIComponent(last); } catch { return last; }
            } catch {
                return null;
            }
        }

        function findBoneMapping(boneName) {
            if (combinedRigMap[boneName]) {
                return combinedRigMap[boneName];
            }
            const lowerName = boneName.toLowerCase();
            for (const [key, value] of Object.entries(combinedRigMap)) {
                if (key.toLowerCase() === lowerName) {
                    return value;
                }
            }
            for (const [vrmBone, pattern] of Object.entries(namePatterns)) {
                if (pattern.test(boneName)) {
                    return vrmBone;
                }
            }
            return null;
        }

        function loadHumanoidAnimation(url, vrm) {
            const loader = new FBXLoader();
            loader.crossOrigin = 'anonymous';
            return loader.loadAsync(url).then((asset) => {
                let clip = THREE.AnimationClip.findByName(asset.animations, 'mixamo.com');
                if (!clip && asset.animations.length > 0) {
                    clip = asset.animations[0];
                }
                if (!clip) {
                    throw new Error('No animation found in FBX file');
                }
                const tracks = [];
                const restRotationInverse = new THREE.Quaternion();
                const parentRestWorldRotation = new THREE.Quaternion();
                const _quatA = new THREE.Quaternion();
                const _vec3 = new THREE.Vector3();
                let hipsNode = null;
                asset.traverse((node) => {
                    if (!hipsNode) {
                        const vrmBoneName = findBoneMapping(node.name);
                        if (vrmBoneName === 'hips') {
                            hipsNode = node;
                        }
                    }
                });
                let hipsPositionScale = 1.0;
                if (hipsNode) {
                    const motionHipsHeight = hipsNode.position.y;
                    const vrmHipsY = vrm.humanoid?.getNormalizedBoneNode('hips')?.getWorldPosition(_vec3).y || 1;
                    const vrmRootY = vrm.scene.getWorldPosition(_vec3).y;
                    const vrmHipsHeight = Math.abs(vrmHipsY - vrmRootY);
                    if (motionHipsHeight > 0) {
                        hipsPositionScale = vrmHipsHeight / motionHipsHeight;
                    }
                }
                clip.tracks.forEach((track) => {
                    const trackSplitted = track.name.split('.');
                    const rigBoneName = trackSplitted[0];
                    const vrmBoneName = findBoneMapping(rigBoneName);
                    if (!vrmBoneName) {
                        return;
                    }
                    const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName)?.name;
                    const rigNode = asset.getObjectByName(rigBoneName);
                    if (vrmNodeName != null && rigNode) {
                        const propertyName = trackSplitted[1];
                        rigNode.getWorldQuaternion(restRotationInverse).invert();
                        rigNode.parent.getWorldQuaternion(parentRestWorldRotation);
                        if (track instanceof THREE.QuaternionKeyframeTrack) {
                            for (let i = 0; i < track.values.length; i += 4) {
                                const flatQuaternion = track.values.slice(i, i + 4);
                                _quatA.fromArray(flatQuaternion);
                                _quatA.premultiply(parentRestWorldRotation).multiply(restRotationInverse);
                                _quatA.toArray(flatQuaternion);
                                flatQuaternion.forEach((v, index) => {
                                    track.values[index + i] = v;
                                });
                            }
                            tracks.push(
                                new THREE.QuaternionKeyframeTrack(
                                    `${vrmNodeName}.${propertyName}`,
                                    track.times,
                                    track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 2 === 0 ? - v : v)),
                                ),
                            );
                        } else if (track instanceof THREE.VectorKeyframeTrack) {
                            const value = track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 3 !== 1 ? - v : v) * hipsPositionScale);
                            tracks.push(new THREE.VectorKeyframeTrack(`${vrmNodeName}.${propertyName}`, track.times, value));
                        }
                    }
                });
                return new THREE.AnimationClip('vrmAnimation', clip.duration, tracks);
            });
        }

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        // Camera state with smooth lerp to support call mode zooming
        camera.position.set(0.0, 1.0, 5.0);
        const __camDesiredPos = new THREE.Vector3(0.0, 1.0, 5.0);
        const __camDesiredTarget = new THREE.Vector3(0.0, 1.0, 0.0);
        let __callMode = false;
        const __tmpVec3 = new THREE.Vector3();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.screenSpacePanning = true;
        controls.target.set(0.0, 1.0, 0.0);
        controls.update();
        controls.enabled = false;

        const scene = new THREE.Scene();

        // Transparent background for embedding
        scene.background = null;

        const light = new THREE.DirectionalLight(0xffffff, Math.PI);
        light.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(light);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        let currentVrm = undefined;
        let currentAnimationUrl = undefined;
        let currentMixer = undefined;
        let currentAction = undefined;
        let lastUsedAnimationIndex = -1;
        let blinkInterval = undefined;
        // Removed HTML-side BGM variables; Swift manages all music playback.
        let smileController = undefined;
        let ambientController = undefined;
        let postLoadBlurTimerId = undefined;

        // Utilities for call mode camera and background
        function __applyCallBackgroundBlur(enabled) {
            try {
                const overlay = document.getElementById('bgFadeOverlay');
                if (!overlay) return;
                if (enabled) {
                    // Mirror body's current background to overlay to blur it
                    const bodyBg = window.getComputedStyle(document.body).backgroundImage;
                    if (bodyBg && bodyBg !== 'none') {
                        // Extract URL('...') and apply directly; if smoothSetBackground has a newer url it will override shortly
                        overlay.style.backgroundImage = bodyBg;
                    }
                    overlay.classList.add('call-blur');
                } else {
                    overlay.classList.remove('call-blur');
                }
            } catch { }
        }

        function __updateCameraTargetsForMode() {
            // Default framing
            let targetY = 1.0;
            let posZ = __callMode ? 1.8 : 5.0; // closer in call mode
            let fov = __callMode ? 24.0 : 30.0; // slightly tighter FOV

            // If we have a VRM, try to focus on the head for better framing
            try {
                if (__callMode && currentVrm && currentVrm.humanoid) {
                    const wp = new THREE.Vector3();
                    const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                    if (head) {
                        head.getWorldPosition(wp);
                        __camDesiredTarget.set(wp.x, wp.y, wp.z);
                        targetY = wp.y;
                    } else {
                        __camDesiredTarget.set(0.0, targetY, 0.0);
                    }
                } else {
                    // Non-call mode: use simple baseline like yesterday's build
                    __camDesiredTarget.set(0.0, 1.0, 0.0);
                    targetY = 1.0;
                }
            } catch {
                __camDesiredTarget.set(0.0, 1.0, 0.0);
                targetY = 1.0;
            }

            // Place camera in front of the target along Z axis in world space
            __camDesiredPos.set(__camDesiredTarget.x, targetY, __camDesiredTarget.z + posZ);
            camera.fov = fov;
            camera.updateProjectionMatrix();
        }

        // Public API for native: enable/disable call mode
        window.setCallMode = function (enabled) {
            try {
                __callMode = !!enabled;
                __applyCallBackgroundBlur(__callMode);
                __updateCameraTargetsForMode();
            } catch { }
        };

        window.isCallModeActive = function () { return !!__callMode; };

        const helperRoot = new THREE.Group();
        helperRoot.renderOrder = 10000;
        helperRoot.visible = false;
        scene.add(helperRoot);

        // Loading UI helpers
        function setModelLoading(isLoading) {
            try {
                const overlay = document.getElementById('loadingOverlay');
                const canvas = renderer?.domElement;
                if (!overlay || !canvas) return;
                overlay.style.display = isLoading ? 'flex' : 'none';
                // Manage blur on canvas: blur while loading, remove when loaded
                if (isLoading) {
                    if (postLoadBlurTimerId) { clearTimeout(postLoadBlurTimerId); postLoadBlurTimerId = undefined; }
                    canvas.classList.add('loading-blur');
                } else {
                    if (postLoadBlurTimerId) { clearTimeout(postLoadBlurTimerId); postLoadBlurTimerId = undefined; }
                    try { canvas.classList.remove('loading-blur'); } catch { }
                    try { overlayHiddenAt = performance.now(); } catch { }
                    try {
                        if (currentAnimationUrl) {
                            const name = safeFileNameFromUrl(currentAnimationUrl) || 'Animation';
                            loadFBX(currentAnimationUrl, name, 0.5);
                        } else if (lastUsedAnimationIndex === -1) {
                            const idleName = getDefaultIdleAnimation();
                            if (idleName) {
                                getAnimationURL(idleName).then(u => { if (u) loadFBX(u, idleName, 0.5); });
                            }
                        } else if (window.loadNextAnimation) {
                            window.loadNextAnimation();
                        }
                    } catch { }
                }
                const text = document.getElementById('loadingText');
                if (!isLoading && text) text.textContent = 'Loading... 0%';
            } catch { }
        }
        function updateLoadingProgress(percent) {
            try {
                const text = document.getElementById('loadingText');
                if (text) text.textContent = `Loading... ${Math.max(0, Math.min(100, percent | 0))}%`;
                if ((percent | 0) >= 100 && progress100At == null) { try { progress100At = performance.now(); notifyInitialReadyIfDone(); } catch { } }
            } catch { }
        }

        function getRandomItem(array) {
            if (!array || array.length === 0) return null;
            return array[Math.floor(Math.random() * array.length)];
        }

        function getNextAnimation() {
            if (!fbxFiles || fbxFiles.length === 0) return null;
            let attempts = 0;
            let randomIndex;
            let randomFBX;
            do {
                randomIndex = Math.floor(Math.random() * fbxFiles.length);
                randomFBX = fbxFiles[randomIndex];
                attempts++;
            } while (randomIndex === lastUsedAnimationIndex && attempts < 10 && fbxFiles.length > 1);
            lastUsedAnimationIndex = randomIndex;
            return randomFBX;
        }

        // Calm default animation for first-time auto-play
        function getDefaultIdleAnimation() {
            if (!fbxFiles || fbxFiles.length === 0) return null;
            const priorities = [
                /idle/i,
                /stand/i,
                /greet|greeting|hello|wave/i,
                /hand\s*raising/i,
                /talk/i
            ];
            for (const p of priorities) {
                const match = fbxFiles.find(name => p.test(name));
                if (match) return match;
            }
            return null;
        }

        function updateFileDisplay(modelName, animationName) {
            document.getElementById('currentModel').textContent = modelName || 'None';
            document.getElementById('currentAnimation').textContent = animationName || 'None';
        }

        let expressionsFolder = null;
        let expressionParams = {};

        const commonExpressions = [
            'blink', 'blinkLeft', 'blinkRight', 'wink', 'winkLeft', 'winkRight',
            'aa', 'ih', 'ou', 'ee', 'oh', 'teethOpen',
            'lookUp', 'lookDown', 'lookLeft', 'lookRight',
            'happy', 'relaxed', 'surprised', 'angry', 'sad', 'fun', 'lowered', 'raised', 'joy'
        ];

        function setupBlendshapes(vrm) {
            if (!vrm || !vrm.expressionManager) {
                return;
            }
            if (expressionsFolder) {
                gui.removeFolder(expressionsFolder);
                expressionsFolder = null;
                expressionParams = {};
            }
            expressionsFolder = gui.addFolder('Expressions');
            let validExpressions = [];
            if (vrm.expressionManager.expressionMap) {
                validExpressions = Object.keys(vrm.expressionManager.expressionMap);
            } else if (vrm.expressionManager._expressionMap) {
                validExpressions = Object.keys(vrm.expressionManager._expressionMap);
            } else if (vrm.expressionManager.expressions) {
                validExpressions = Object.keys(vrm.expressionManager.expressions);
            } else if (Array.isArray(vrm.expressionManager.blinkExpressionNames)) {
                validExpressions = [
                    ...vrm.expressionManager.blinkExpressionNames,
                    ...(vrm.expressionManager.mouthExpressionNames || []),
                    ...(vrm.expressionManager.lookAtExpressionNames || [])
                ];
            } else {
                validExpressions = commonExpressions;
            }
            for (const name of validExpressions) {
                if (Object.prototype.hasOwnProperty.call(expressionParams, name)) continue;
                expressionParams[name] = 0.0;
                try {
                    const controller = expressionsFolder.add(expressionParams, name, 0.0, 1.0, 0.01);
                    controller.onChange((value) => {
                        if (vrm && vrm.expressionManager) {
                            try {
                                vrm.expressionManager.setValue(name, value);
                            } catch { }
                        }
                    });
                } catch {
                    delete expressionParams[name];
                }
            }
            if (Object.keys(expressionParams).length > 0) {
                expressionsFolder.open();
            }
        }

        function startRandomBlinking(vrm) {
            if (!vrm || !vrm.expressionManager) return;
            stopRandomBlinking();
            // Store reference to current vrm for this instance
            const targetVrm = vrm;
            console.log('Starting blinking for VRM:', vrm);
            const blinkExpressions = ['blink', 'blinkLeft', 'blinkRight', 'Blink', 'eyesClosed'];
            let blinkAnimationFrame = null;
            let blinkStartTime = 0;
            let isBlinking = false;
            let currentBlinkValue = 0.0;
            const animateBlink = (timestamp) => {
                if (!isBlinking) {
                    blinkAnimationFrame = requestAnimationFrame(animateBlink);
                    return;
                }
                const elapsed = (timestamp - blinkStartTime) / 1000;
                const blinkDuration = 0.15;
                if (elapsed < blinkDuration) {
                    let blinkProgress;
                    if (elapsed < blinkDuration / 2) {
                        blinkProgress = 0.5 * (1 - Math.cos(Math.PI * elapsed / (blinkDuration / 2)));
                    } else {
                        const openElapsed = elapsed - blinkDuration / 2;
                        blinkProgress = 0.5 * (1 + Math.cos(Math.PI * openElapsed / (blinkDuration / 2)));
                    }
                    currentBlinkValue = Math.min(1.0, blinkProgress);
                    if (targetVrm && targetVrm.expressionManager) {
                        for (const blinkName of blinkExpressions) {
                            try { targetVrm.expressionManager.setValue(blinkName, currentBlinkValue); } catch { }
                        }
                    }
                    blinkAnimationFrame = requestAnimationFrame(animateBlink);
                } else {
                    isBlinking = false;
                    currentBlinkValue = 0.0;
                    if (targetVrm && targetVrm.expressionManager) {
                        for (const blinkName of blinkExpressions) {
                            try { targetVrm.expressionManager.setValue(blinkName, 0.0); } catch { }
                        }
                    }
                }
            };
            blinkAnimationFrame = requestAnimationFrame(animateBlink);
            const performBlink = () => {
                if (!targetVrm || !targetVrm.expressionManager || isBlinking) return;
                isBlinking = true;
                blinkStartTime = performance.now();
            };
            let scheduleTimeout = null;
            const scheduleBlink = () => {
                // While speaking, blink more often (1‚Äì2s). Otherwise 1‚Äì3s.
                const speaking = performance.now() < __speechActiveUntil;
                const randomInterval = speaking ? (Math.random() * 1 + 1) * 1000 : (Math.random() * 2 + 1) * 1000;
                scheduleTimeout = setTimeout(() => {
                    performBlink();
                    scheduleBlink();
                }, randomInterval);
            };
            scheduleBlink();
            blinkInterval = {
                cancel: () => {
                    cancelAnimationFrame(blinkAnimationFrame);
                    if (scheduleTimeout) {
                        clearTimeout(scheduleTimeout);
                        scheduleTimeout = null;
                    }
                }
            };
        }

        function stopRandomBlinking() {
            if (blinkInterval) {
                if (blinkInterval.cancel) { blinkInterval.cancel(); }
                blinkInterval = undefined;
            }
        }

        // Periodic smiling similar to blinking
        function startRandomSmiling(vrm) {
            if (!vrm || !vrm.expressionManager) return;
            stopRandomSmiling();
            const targetVrm = vrm;
            console.log('Starting smiling for VRM:', vrm);
            const smileExpressions = ['happy', 'joy', 'Joy', 'smile', 'Smile', 'fun', 'relaxed', 'smileOpen'];
            let smileAnimationFrame = null;
            let smileStartTime = 0;
            let isSmiling = false;
            let phase = 'in'; // 'in' -> 'hold' -> 'out'
            const durations = { in: 0.3, hold: 0.25, out: 0.3 };
            const maxSmile = 0.22; // subtle peak intensity

            const setSmileValue = (v) => {
                if (targetVrm && targetVrm.expressionManager) {
                    for (const n of smileExpressions) {
                        try { targetVrm.expressionManager.setValue(n, v); } catch { }
                    }
                }
            };

            const animateSmile = (timestamp) => {
                if (!isSmiling) {
                    smileAnimationFrame = requestAnimationFrame(animateSmile);
                    return;
                }
                const t = (timestamp - smileStartTime) / 1000;
                let value = 0.0;
                if (phase === 'in') {
                    const p = Math.min(1, t / durations.in);
                    value = 0.5 * (1 - Math.cos(Math.PI * p)); // ease-in
                    if (p >= 1) { phase = 'hold'; smileStartTime = timestamp; }
                } else if (phase === 'hold') {
                    value = 1.0;
                    if (t >= durations.hold) { phase = 'out'; smileStartTime = timestamp; }
                } else {
                    const p = Math.min(1, t / durations.out);
                    value = 1 - 0.5 * (1 - Math.cos(Math.PI * p)); // ease-out
                    if (p >= 1) { isSmiling = false; value = 0.0; }
                }
                const clamped = Math.max(0, Math.min(1, value));
                setSmileValue(maxSmile * clamped);
                smileAnimationFrame = requestAnimationFrame(animateSmile);
            };
            smileAnimationFrame = requestAnimationFrame(animateSmile);

            const performSmile = () => {
                if (!targetVrm || !targetVrm.expressionManager || isSmiling) return;
                isSmiling = true;
                phase = 'in';
                smileStartTime = performance.now();
            };

            let smileScheduleTimeout = null;
            const scheduleSmile = () => {
                const intervalMs = (Math.random() * 5 + 5) * 1000; // 5-10s
                smileScheduleTimeout = setTimeout(() => {
                    performSmile();
                    scheduleSmile();
                }, intervalMs);
            };
            scheduleSmile();
            smileController = {
                cancel: () => {
                    cancelAnimationFrame(smileAnimationFrame);
                    if (smileScheduleTimeout) {
                        clearTimeout(smileScheduleTimeout);
                        smileScheduleTimeout = null;
                    }
                },
                clear: () => setSmileValue(0.0)
            };
        }

        function stopRandomSmiling() {
            if (smileController) {
                try { if (smileController.clear) smileController.clear(); } catch { }
                try { if (smileController.cancel) smileController.cancel(); } catch { }
                smileController = undefined;
            }
        }

        // Ambient micro-expressions: randomly trigger subtle positive expressions with random intensity/duration
        function startAmbientMicroExpressions(vrm) {
            if (!vrm || !vrm.expressionManager) return;
            stopAmbientMicroExpressions();
            const targetVrm = vrm;
            console.log('Starting ambient expressions for VRM:', vrm);
            const positiveCandidates = [
                'happy', 'joy', 'fun', 'relaxed', 'lowered', 'raised', // generic positive/eyebrow
                'ee', 'oh', 'aa', 'ih', 'ou' // subtle mouth shapes (speech-like micro-movements)
            ];

            let raf = null;
            let active = false;
            let startTime = 0;
            let duration = 0.6;
            let maxIntensity = 0.15;
            let targetNames = [];
            let phase = 'in';

            const setValues = (v) => {
                if (targetVrm && targetVrm.expressionManager) {
                    for (const n of targetNames) {
                        try { targetVrm.expressionManager.setValue(n, v); } catch { }
                    }
                }
            };

            const chooseTargets = () => {
                // Choose 1‚Äì2 expressions randomly
                const count = Math.random() < 0.65 ? 1 : 2;
                const picks = [];
                const pool = positiveCandidates.slice();
                while (picks.length < count && pool.length > 0) {
                    const i = (Math.random() * pool.length) | 0;
                    picks.push(pool.splice(i, 1)[0]);
                }
                return picks;
            };

            const animate = (ts) => {
                if (!active) { raf = requestAnimationFrame(animate); return; }
                const t = (ts - startTime) / 1000;
                let value = 0.0;
                const inDur = duration * 0.35;
                const holdDur = duration * 0.3;
                const outDur = duration * 0.35;
                if (phase === 'in') {
                    const p = Math.min(1, t / inDur);
                    value = 0.5 * (1 - Math.cos(Math.PI * p));
                    if (p >= 1) { phase = 'hold'; startTime = ts; }
                } else if (phase === 'hold') {
                    value = 1.0;
                    if (t >= holdDur) { phase = 'out'; startTime = ts; }
                } else {
                    const p = Math.min(1, t / outDur);
                    value = 1 - 0.5 * (1 - Math.cos(Math.PI * p));
                    if (p >= 1) { active = false; value = 0.0; }
                }
                setValues(maxIntensity * Math.max(0, Math.min(1, value)));
                raf = requestAnimationFrame(animate);
            };
            raf = requestAnimationFrame(animate);

            const trigger = () => {
                if (!targetVrm || !targetVrm.expressionManager || active) return;
                // Randomize parameters per event
                targetNames = chooseTargets();
                maxIntensity = 0.07 + Math.random() * 0.13; // 0.07‚Äì0.20
                duration = 0.5 + Math.random() * 0.7; // 0.5‚Äì1.2s
                phase = 'in';
                active = true;
                startTime = performance.now();
            };

            let ambientScheduleTimeout = null;
            const schedule = () => {
                const interval = (Math.random() * 4 + 3.5) * 1000; // 3.5‚Äì7.5s
                ambientScheduleTimeout = setTimeout(() => {
                    trigger();
                    schedule();
                }, interval);
            };
            schedule();
            ambientController = {
                cancel: () => {
                    cancelAnimationFrame(raf);
                    if (ambientScheduleTimeout) {
                        clearTimeout(ambientScheduleTimeout);
                        ambientScheduleTimeout = null;
                    }
                },
                clear: () => setValues(0.0)
            };
        }

        function stopAmbientMicroExpressions() {
            if (ambientController) {
                try { if (ambientController.clear) ambientController.clear(); } catch { }
                try { if (ambientController.cancel) ambientController.cancel(); } catch { }
                ambientController = undefined;
            }
        }

        function loadVRM(modelUrl, modelName, animationToLoad = null) {
            const loader = new GLTFLoader();
            loader.crossOrigin = 'anonymous';
            helperRoot.clear();
            loader.register((parser) => new VRMLoaderPlugin(parser, { helperRoot: helperRoot, autoUpdateHumanBones: true }));
            // show loading overlay
            setModelLoading(true);
            loader.load(
                modelUrl,
                (gltf) => {
                    const vrm = gltf.userData.vrm;
                    VRMUtils.removeUnnecessaryVertices(gltf.scene);
                    VRMUtils.combineSkeletons(gltf.scene);
                    // Don't combine morphs - it interferes with expression blendshapes
                    // VRMUtils.combineMorphs( vrm );
                    if (currentVrm) {
                        stopRandomBlinking();
                        stopRandomSmiling();
                        stopAmbientMicroExpressions();
                        scene.remove(currentVrm.scene);
                        VRMUtils.deepDispose(currentVrm.scene);
                    }
                    currentVrm = vrm;
                    scene.add(vrm.scene);
                    currentMixer = new THREE.AnimationMixer(currentVrm.scene);
                    // Clear any previous action from old mixer to avoid cross-fading across mixers
                    currentAction = undefined;
                    vrm.scene.traverse((obj) => { obj.frustumCulled = false; });
                    VRMUtils.rotateVRM0(vrm);
                    updateFileDisplay(modelName, document.getElementById('currentAnimation').textContent);
                    setupBlendshapes(vrm);

                    // Start expressions after animation is applied
                    const startExpressions = () => {
                        startRandomBlinking(vrm);
                        startRandomSmiling(vrm);
                        startAmbientMicroExpressions(vrm);
                    };

                    if (animationToLoad) {
                        // Defer auto-play until post-load blur finishes; only set the selected animation name
                        (async () => {
                            try {
                                const animName = safeFileNameFromUrl(animationToLoad);
                                currentAnimationUrl = animationToLoad;
                                updateFileDisplay(modelName, animName || 'Animation');
                            } catch { }
                        })();
                    } else {
                        // No animation to load, start expressions after a short delay
                        setTimeout(startExpressions, 500);
                    }
                    // Notify Swift that model is loaded and scene attached
                    try { window.webkit?.messageHandlers?.loading?.postMessage('modelLoaded'); } catch { }
                    try { if (window.ReactNativeWebView) window.ReactNativeWebView.postMessage('modelLoaded'); } catch { }
                    // hide loading overlay
                    setModelLoading(false);

                    // Re-evaluate desired camera framing after model attaches
                    try { __updateCameraTargetsForMode(); } catch { }
                },
                (progress) => {
                    const percent = progress.total ? (100.0 * (progress.loaded / progress.total)) : 0;
                    updateFileDisplay(`Loading... ${percent.toFixed(0)}%`, document.getElementById('currentAnimation').textContent);
                    updateLoadingProgress(percent);
                },
                (error) => {
                    /* error loading VRM */
                    updateFileDisplay('Error loading model', document.getElementById('currentAnimation').textContent);
                    setModelLoading(false);
                },
            );
        }

        function loadFBX(animationUrl, animationName, crossFadeDuration = 0.5) {
            currentAnimationUrl = animationUrl;
            if (!currentMixer || !currentVrm) {
                /* please load a VRM model first */
                return;
            }
            updateFileDisplay(document.getElementById('currentModel').textContent, `Loading ${animationName}...`);
            loadHumanoidAnimation(animationUrl, currentVrm)
                .then((clip) => {
                    const newAction = currentMixer.clipAction(clip);
                    newAction.reset();
                    if (currentAction && currentAction !== newAction) {
                        newAction.play();
                        currentAction.crossFadeTo(newAction, crossFadeDuration, true);
                    } else {
                        newAction.play();
                    }
                    currentAction = newAction;
                    updateFileDisplay(document.getElementById('currentModel').textContent, animationName);
                    if (!initialAnimationApplied) {
                        initialAnimationApplied = true;
                        console.log('‚úÖ Animation applied, checking initial ready...');
                        notifyInitialReadyIfDone();
                    }

                    // Start expressions after animation has started playing
                    if (currentVrm) {
                        setTimeout(() => {
                            // Only start if not already running
                            if (!blinkInterval) {
                                startRandomBlinking(currentVrm);
                                startRandomSmiling(currentVrm);
                                startAmbientMicroExpressions(currentVrm);
                            }
                        }, 200);
                    }
                })
                .catch((error) => {
                    /* error loading animation */
                    updateFileDisplay(document.getElementById('currentModel').textContent, 'Error: ' + error.message);
                });
        }

        window.loadRandomFiles = async function () {
            try {
                console.log('üé≤ loadRandomFiles called');
                const randomVRM = getRandomItem(vrmFiles);
                const randomFBX = getNextAnimation();
                console.log('üé≤ Selected random VRM:', randomVRM, 'Animation:', randomFBX);

                if (randomVRM && randomFBX) {
                    const vrmUrl = await getModelURL(randomVRM);
                    console.log('üì¶ Loading VRM from URL:', vrmUrl);
                    // Do not start animation immediately; it will auto-play after post-load blur
                    loadVRM(vrmUrl, randomVRM);
                    // Start background preloading excluding current selections
                    startBackgroundPreloading(randomVRM, randomFBX);
                } else if (randomVRM) {
                    const vrmUrl = await getModelURL(randomVRM);
                    console.log('üì¶ Loading VRM from URL:', vrmUrl);
                    loadVRM(vrmUrl, randomVRM);
                    startBackgroundPreloading(randomVRM, null);
                } else {
                    console.error('‚ùå No VRM files available!');
                }
            } catch (e) {
                console.error('‚ùå Error in loadRandomFiles:', e);
            }
        }

        window.loadNextAnimation = async function () {
            if (!currentVrm || !currentMixer) {
                alert('Please load a VRM model first');
                return;
            }
            const nextFBX = getNextAnimation();
            if (nextFBX) {
                const fbxUrl = await getAnimationURL(nextFBX);
                const btn = document.getElementById('nextAnimBtn');
                const originalText = btn.textContent;
                btn.textContent = 'Loading...';
                btn.disabled = true;
                loadFBX(fbxUrl, nextFBX, 0.8);
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 1500);
            }
        }

        // Removed HTML-side background music functions; Swift layer owns playback.

        // Load a specific VRM model by file name (exposed to SwiftUI)
        window.loadModelByName = async function (modelName) {
            try {
                const vrmUrl = await getModelURL(modelName);
                if (!vrmUrl) return;
                loadVRM(vrmUrl, modelName);
                // Optionally kick off background preloading excluding the current selection
                startBackgroundPreloading(modelName, null);
            } catch (e) {
                /* error loading model by name */
            }
        }

        // Load a VRM model by direct URL (optional display name)
        window.loadModelByURL = async function (url, name = 'Remote Model') {
            try {
                if (!url) return;
                loadVRM(url, name);
                startBackgroundPreloading(null, null);
            } catch (e) {
                /* error loading model by URL */
            }
        }

        window.addEventListener('DOMContentLoaded', async function () {
            // Apply initial background from native if provided
            try {
                if (typeof window.initialBackgroundUrl === 'string' && window.initialBackgroundUrl.trim().length) {
                    const url = window.initialBackgroundUrl.trim();
                    document.body.style.backgroundImage = `url('${url}')`;
                    // Mark ready since background is applied synchronously
                    if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
                } else {
                    // If no background URL provided, mark as ready anyway (use default background)
                    // This ensures initialReady can be sent even without persisted background
                    if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
                }
            } catch {
                // On error, mark background as ready anyway to allow initialReady
                if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
            }

            // Allow native (Swift) to preselect a model name or URL for later, but do not auto-load here.
            // Swift will explicitly call window.loadModelByName/URL at the appropriate time after preferences/assets are ready.
            const nativeName = (typeof window.nativeSelectedModelName === 'string' && window.nativeSelectedModelName.trim().length) ? window.nativeSelectedModelName.trim() : null;
            const nativeURL = (typeof window.nativeSelectedModelURL === 'string' && window.nativeSelectedModelURL.trim().length) ? window.nativeSelectedModelURL.trim() : null;
            const isReactNative =
                typeof window.__isReactNativeShell !== 'undefined'
                    ? !!window.__isReactNativeShell
                    : typeof window.ReactNativeWebView !== 'undefined';
            console.log('üîç Initial model context', { nativeName, nativeURL, isReactNative });

            // Auto-load model if provided (for React Native version)
            if (nativeName) {
                try {
                    console.log('üì¶ Loading model by name:', nativeName);
                    await window.loadModelByName(nativeName);
                } catch (e) {
                    console.error('Failed to load model by name:', e);
                    // Fallback to random model on error
                    try {
                        console.log('üîÑ Falling back to random model...');
                        await window.loadRandomFiles();
                    } catch (e2) {
                        console.error('Failed to load random model:', e2);
                        if (!initialAnimationApplied) { initialAnimationApplied = true; notifyInitialReadyIfDone(); }
                    }
                }
            } else if (nativeURL) {
                try {
                    console.log('üì¶ Loading model by URL:', nativeURL);
                    await window.loadModelByURL(nativeURL);
                } catch (e) {
                    console.error('Failed to load model by URL:', e);
                    // Fallback to random model on error
                    try {
                        console.log('üîÑ Falling back to random model...');
                        await window.loadRandomFiles();
                    } catch (e2) {
                        console.error('Failed to load random model:', e2);
                        if (!initialAnimationApplied) { initialAnimationApplied = true; notifyInitialReadyIfDone(); }
                    }
                }
            } else if (!isReactNative) {
                // If no model selected, load a random model automatically
                // This ensures VRM is visible on screen
                try {
                    console.log('üé≤ No model selected, loading random model...');
                    await window.loadRandomFiles();
                } catch (e) {
                    console.error('Failed to load random model:', e);
                    // If random load fails, mark animation as ready anyway
                    if (!initialAnimationApplied) { initialAnimationApplied = true; notifyInitialReadyIfDone(); }
                }
            } else {
                // Running inside React Native but no persisted selection yet.
                // Avoid flashing a random model; wait for native to instruct via injected JS.
                console.log('‚è≥ React Native context detected with no persisted VRM. Waiting for native model load...');
                if (!initialAnimationApplied) { initialAnimationApplied = true; notifyInitialReadyIfDone(); }
            }

            // No HTML-side BGM initialization
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            if (currentMixer) { currentMixer.update(deltaTime); }
            if (currentVrm) { currentVrm.update(deltaTime); }
            // No HTML-side BGM ducking
            // Smoothly move camera and target towards desired state
            try {
                // In call mode, continuously track the head to keep framing tight
                if (__callMode && currentVrm && currentVrm.humanoid) {
                    const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                    if (head) {
                        head.getWorldPosition(__tmpVec3);
                        // Slight upward bias for pleasing composition
                        const targetY = __tmpVec3.y;
                        __camDesiredTarget.set(__tmpVec3.x, targetY, __tmpVec3.z);
                        // Keep a fixed world-space offset in front of the head
                        const zOffset = 1.8;
                        const yOffset = 0.05;
                        __camDesiredPos.set(__camDesiredTarget.x, targetY + yOffset, __camDesiredTarget.z + zOffset);
                    }
                }
                camera.position.lerp(__camDesiredPos, 0.08);
                controls.target.lerp(__camDesiredTarget, 0.12);
                controls.update();
            } catch { }
            renderer.render(scene, camera);
        }
        animate();

        const gui = new GUI();
        const params = { timeScale: 1.0, showHelpers: false };
        gui.add(params, 'timeScale', 0.0, 2.0, 0.001).onChange((value) => {
            if (currentMixer) { currentMixer.timeScale = value; }
        });
        gui.add(params, 'showHelpers').onChange((value) => { helperRoot.visible = value; });

        window.addEventListener('dragover', function (event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
        });
        window.addEventListener('drop', function (event) {
            event.preventDefault();
            const files = event.dataTransfer.files;
            if (!files) return;
            const file = files[0];
            if (!file) return;
            const fileType = file.name.split('.').pop().toLowerCase();
            const blob = new Blob([file], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            if (fileType === 'fbx') {
                currentAnimationUrl = url;
                if (currentVrm && currentMixer) {
                    loadFBX(url, file.name);
                } else {
                    alert('Please load a VRM model first before loading animation');
                }
            } else if (fileType === 'vrm' || fileType === 'glb' || fileType === 'gltf') {
                loadVRM(url, file.name);
            } else {
                alert('Unsupported file type. Please drop a .vrm, .glb, .gltf, or .fbx file');
            }
        });

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Re-apply desired targets after size changes
            try { __updateCameraTargetsForMode(); } catch { }
        });

        // Expose handlers for native SwiftUI buttons
        (() => {
            // Dynamically fetched backgrounds
            let backgroundList = [];
            let bgIndex = -1;
            // Guard to sequence background transitions and avoid flicker/race
            let bgTransitionId = 0;

            async function fetchBackgrounds() {
                try {
                    const res = await fetch('https://n8n8n.top/webhook/backgrounds', { mode: 'cors' });
                    const data = await res.json();
                    if (Array.isArray(data)) {
                        backgroundList = data.filter(r => r && (r.image || r.thumbnail));
                        if (backgroundList.length > 0 && bgIndex < 0) {
                            // Do not auto-apply a new background on initial load
                            // Just initialize index - do NOT mark background as ready
                            // Swift will set the background via setBackgroundImage()
                            bgIndex = 0;
                        }
                    }
                } catch {
                    // Don't mark background as ready on error - wait for Swift to set it
                }
            }

            function smoothSetBackground(url) {
                try {
                    const overlay = document.getElementById('bgFadeOverlay');
                    if (!overlay || !url) {
                        document.body.style.backgroundImage = `url('${url}')`;
                        // Mark as ready if not already marked (for immediate sets)
                        if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
                        return;
                    }
                    const myId = ++bgTransitionId;
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        if (myId !== bgTransitionId) return; // superseded
                        overlay.style.transition = 'none';
                        overlay.style.backgroundImage = `url('${url}')`;
                        overlay.style.opacity = '0';
                        void overlay.offsetWidth; // reflow
                        overlay.style.transition = 'opacity 400ms ease';
                        overlay.style.opacity = '1';
                        setTimeout(() => {
                            if (myId !== bgTransitionId) return;
                            document.body.style.backgroundImage = `url('${url}')`;
                            overlay.style.opacity = __callMode ? '1' : '0';
                            // Ensure blur state persists after transition
                            if (__callMode) {
                                overlay.classList.add('call-blur');
                            } else {
                                overlay.classList.remove('call-blur');
                            }
                            // Mark background as ready after transition completes
                            if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
                        }, 420);
                    };
                    img.onerror = () => {
                        if (myId !== bgTransitionId) return;
                        document.body.style.backgroundImage = `url('${url}')`;
                        // Mark as ready even on error (background was set)
                        if (!initialBackgroundReady) { initialBackgroundReady = true; notifyInitialReadyIfDone(); }
                        // Maintain blur state
                        if (__callMode) {
                            overlay.style.backgroundImage = `url('${url}')`;
                            overlay.classList.add('call-blur');
                            overlay.style.opacity = '1';
                        } else {
                            overlay.classList.remove('call-blur');
                            overlay.style.opacity = '0';
                        }
                    };
                    img.src = url;
                } catch { }
            }

            // Public controls
            window.nextBackground = function () {
                try {
                    if (!backgroundList.length) { fetchBackgrounds(); return; }
                    bgIndex = (bgIndex + 1) % backgroundList.length;
                    const url = backgroundList[bgIndex].image || backgroundList[bgIndex].thumbnail;
                    if (url) smoothSetBackground(url);
                } catch { }
            };
            window.prevBackground = function () {
                try {
                    if (!backgroundList.length) { fetchBackgrounds(); return; }
                    bgIndex = (bgIndex - 1 + backgroundList.length) % backgroundList.length;
                    const url = backgroundList[bgIndex].image || backgroundList[bgIndex].thumbnail;
                    if (url) smoothSetBackground(url);
                } catch { }
            };
            window.setBackgroundImage = function (url) {
                try {
                    if (url) smoothSetBackground(url);
                    // Try to align bgIndex with the provided url if it exists in list
                    const i = backgroundList.findIndex(r => r.image === url || r.thumbnail === url);
                    if (i >= 0) bgIndex = i;
                    // Maintain call mode blur if active
                    if (__callMode) { __applyCallBackgroundBlur(true); }
                } catch { }
            };

            // Expose current background name to native (kept for backward compatibility)
            window.getCurrentRoomName = function () {
                try {
                    if (!backgroundList.length || bgIndex < 0) return '';
                    return backgroundList[bgIndex]?.name || '';
                } catch { return ''; }
            };
            // New function name for consistency
            window.getCurrentBackgroundName = function () {
                try {
                    if (!backgroundList.length || bgIndex < 0) return '';
                    return backgroundList[bgIndex]?.name || '';
                } catch { return ''; }
            };

            // Initial fetch
            fetchBackgrounds();
            window.triggerDance = function () {
                try { window.loadNextAnimation && window.loadNextAnimation(); } catch { }
            };
            window.triggerLove = function () {
                if (!currentVrm || !currentVrm.expressionManager) return;
                const names = ['happy', 'joy', 'fun', 'relaxed'];
                let t0 = performance.now();
                const dur = 0.9;
                const maxV = 0.35;
                const setVal = (v) => { for (const n of names) { try { currentVrm.expressionManager.setValue(n, v); } catch { } } };
                const step = (ts) => {
                    const t = (ts - t0) / 1000;
                    if (t <= dur) {
                        const p = t / dur;
                        const v = p < 0.5 ? (maxV * (0.5 * (1 - Math.cos(Math.PI * (p / 0.5))))) : (maxV * (1 - 0.5 * (1 - Math.cos(Math.PI * ((p - 0.5) / 0.5)))));
                        setVal(Math.max(0, Math.min(maxV, v)));
                        requestAnimationFrame(step);
                    } else {
                        setVal(0.0);
                    }
                };
                requestAnimationFrame(step);
            };
        })();

        // Parallax application: move background subtly with device tilt
        window.applyParallax = (dx, dy) => {
            try {
                const overlay = document.getElementById('bgFadeOverlay');
                const x = Math.max(-100, Math.min(100, Number(dx) || 0));
                const y = 0; // lock Y parallax
                // Translate overlay for smooth GPU movement
                if (overlay) {
                    // Preserve scale applied in call-blur by appending translate
                    const translate = `translate(${x * 0.9}px, ${y}px)`;
                    overlay.style.transform = overlay.classList.contains('call-blur') ? `scale(1.03) ${translate}` : translate;
                }
                // Also nudge body background position as a fallback
                document.body.style.backgroundPosition = `calc(50% + ${x * 0.5}px) 50%`;
            } catch { }
        };

        // Lipsync: set mouth openness [0..1]; damped smoothing
        let __mouthLerp = 0;
        let __speechActiveUntil = 0; // ms timestamp while speech is considered active
        window.setMouthOpen = (v) => {
            try {
                // Amplify and bias for stronger lipsync
                const raw = Math.max(0, Math.min(1, Number(v) || 0));
                // Gain and soft gamma curve make quiet sounds visible and loud sounds pop
                const gain = 3.0;            // stronger amplification
                const gamma = 0.65;          // stronger curve
                const biased = Math.pow(Math.min(1, raw * gain), gamma);
                // Much faster response for more realistic lipsync
                __mouthLerp = 0.15 * __mouthLerp + 0.85 * biased;
                // Mark speech as active for blink scheduling
                if (raw > 0.02) { __speechActiveUntil = performance.now() + 900; }
                if (currentVrm && currentVrm.expressionManager) {
                    // Allow a bigger apparent opening, then clamp
                    const main = Math.max(0, Math.min(1, __mouthLerp * 1.35));
                    // Emphasize "aa" most, others slightly lower to avoid flat mouth shapes
                    const map = [
                        ['aa', main],
                        ['ee', main * 0.8],
                        ['ih', main * 0.75],
                        ['oh', Math.min(1, main * 1.1)],
                        ['ou', Math.min(1, main * 1.05)],
                        ['teethOpen', main * 0.6],
                    ];
                    for (const [n, val] of map) {
                        try { currentVrm.expressionManager.setValue(n, val); } catch { }
                    }
                    // Fallback vowel keys used by some rigs (A,E,I,O,U)
                    const upperMap = [
                        ['A', main],
                        ['E', main * 0.8],
                        ['I', main * 0.75],
                        ['O', Math.min(1, main * 1.1)],
                        ['U', Math.min(1, main * 1.05)],
                    ];
                    for (const [n, val] of upperMap) {
                        try { currentVrm.expressionManager.setValue(n, val); } catch { }
                    }
                }
                // No HTML-side BGM ducking; managed in Swift
            } catch { }
        };

        // Removed applyBgmDucking; Swift manages audio levels
    </script>
</body>

</html>